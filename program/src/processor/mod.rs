use crate::consts::{MX, NFT_AMOUNT, REWARD_PERIOD, SECONDS_IN_THE_DAY, VAULT, WHITELIST};
use crate::error::ContractError;
use crate::instruction::PlatformInstruction;
use crate::state::{ContractData, RateData, StakeData};
use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::account_info::{next_account_info, AccountInfo};
use solana_program::clock::Clock;
use solana_program::entrypoint::ProgramResult;
use solana_program::program::{invoke, invoke_signed};
use solana_program::program_error::ProgramError;
use solana_program::pubkey::Pubkey;
use solana_program::rent::Rent;
use solana_program::sysvar::Sysvar;
use solana_program::{msg, system_instruction};

/// Program state handler
pub struct Processor {}

impl Processor {
    pub fn process(
        program_id: &Pubkey,
        accounts: &[AccountInfo],
        instruction_data: &[u8],
    ) -> ProgramResult {
        let accounts_iter = &mut accounts.iter();

        let instruction: PlatformInstruction =
            match PlatformInstruction::try_from_slice(instruction_data) {
                Ok(insn) => insn,
                Err(err) => {
                    msg!("Failed to deserialize instruction: {}", err);
                    return Err(ContractError::InvalidInstructionData.into());
                }
            };

        let admin = "3CbrdaPTq8RgUaD9JgGZy9rASHW3hUGMqtLt2eWV52Cy"
            .parse::<Pubkey>()
            .unwrap();
        let reward_mint = "H4YPcT8Qgkk6v1nLeCF24T5dA4THcnSKsTAY3SkgsM3j"
            .parse::<Pubkey>()
            .unwrap();

        match instruction {
            PlatformInstruction::GenerateVault => {
                let payer = next_account_info(accounts_iter)?;
                let system_program = next_account_info(accounts_iter)?;
                let pda = next_account_info(accounts_iter)?;
                let rent_info = next_account_info(accounts_iter)?;

                let rent = &Rent::from_account_info(rent_info)?;

                let (vault_pda, vault_bump_seed) =
                    Pubkey::find_program_address(&[VAULT], &program_id);

                if pda.key != &vault_pda {
                    //msg!("Wrong account generated by client");
                    return Err(ProgramError::Custom(0x00));
                }

                if pda.owner != program_id {
                    let size = 8;

                    let required_lamports = rent
                        .minimum_balance(size as usize)
                        .max(1)
                        .saturating_sub(pda.lamports());

                    invoke(
                        &system_instruction::transfer(payer.key, &vault_pda, required_lamports),
                        &[payer.clone(), pda.clone(), system_program.clone()],
                    )?;

                    invoke_signed(
                        &system_instruction::allocate(&vault_pda, size),
                        &[pda.clone(), system_program.clone()],
                        &[&[VAULT, &[vault_bump_seed.clone()]]],
                    )?;

                    invoke_signed(
                        &system_instruction::assign(&vault_pda, program_id),
                        &[pda.clone(), system_program.clone()],
                        &[&[VAULT, &[vault_bump_seed]]],
                    )?;
                }

                if *payer.key != admin || !payer.is_signer {
                    //unauthorized access
                    return Err(ProgramError::Custom(0x02));
                }

                let contract_data = ContractData {
                    reward_period: SECONDS_IN_THE_DAY,
                };

                contract_data.serialize(&mut &mut pda.data.borrow_mut()[..])?;
            }

            PlatformInstruction::AddToWhitelist { price, maxreward } => {
                let payer = next_account_info(accounts_iter)?;
                let creator_info = next_account_info(accounts_iter)?;
                let whitelist_info = next_account_info(accounts_iter)?;
                let sys_info = next_account_info(accounts_iter)?;
                let rent_info = next_account_info(accounts_iter)?;

                let rent = &Rent::from_account_info(rent_info)?;

                if *payer.key != admin || !payer.is_signer {
                    //unauthorized access
                    return Err(ProgramError::Custom(0x31));
                }

                let (data_address, data_address_bump) = Pubkey::find_program_address(
                    &[WHITELIST, &creator_info.key.to_bytes()],
                    &program_id,
                );

                if *whitelist_info.key != data_address {
                    //wrong whitelist_info
                    return Err(ProgramError::Custom(0x32));
                }

                let size = 8 + 8;
                if whitelist_info.owner != program_id {
                    let required_lamports = rent
                        .minimum_balance(size as usize)
                        .max(1)
                        .saturating_sub(whitelist_info.lamports());

                    invoke(
                        &system_instruction::transfer(payer.key, &data_address, required_lamports),
                        &[payer.clone(), whitelist_info.clone(), sys_info.clone()],
                    )?;

                    invoke_signed(
                        &system_instruction::allocate(&data_address, size),
                        &[whitelist_info.clone(), sys_info.clone()],
                        &[&[
                            WHITELIST,
                            &creator_info.key.to_bytes(),
                            &[data_address_bump],
                        ]],
                    )?;

                    invoke_signed(
                        &system_instruction::assign(&data_address, program_id),
                        &[whitelist_info.clone(), sys_info.clone()],
                        &[&[
                            WHITELIST,
                            &creator_info.key.to_bytes(),
                            &[data_address_bump],
                        ]],
                    )?;
                }

                let rate_struct = RateData { price, maxreward };
                rate_struct.serialize(&mut &mut whitelist_info.data.borrow_mut()[..])?;
            }

            PlatformInstruction::Stake => {
                let payer = next_account_info(accounts_iter)?;
                let mint = next_account_info(accounts_iter)?;
                let metadata_account_info = next_account_info(accounts_iter)?;

                let vault_info = next_account_info(accounts_iter)?;
                let source = next_account_info(accounts_iter)?;
                let destination = next_account_info(accounts_iter)?;

                let token_program = next_account_info(accounts_iter)?;
                let sys_info = next_account_info(accounts_iter)?;
                let rent_info = next_account_info(accounts_iter)?;
                let token_assoc = next_account_info(accounts_iter)?;

                let stake_data_info = next_account_info(accounts_iter)?;
                let whitelist_info = next_account_info(accounts_iter)?;

                let clock = Clock::get()?;

                if *token_program.key != spl_token::id() {
                    //wrong token_info
                    return Err(ProgramError::Custom(0x345));
                }

                let rent = &Rent::from_account_info(rent_info)?;
                let (stake_data, stake_data_bump) =
                    Pubkey::find_program_address(&[&mint.key.to_bytes()], &program_id);

                if !payer.is_signer {
                    //unauthorized access
                    return Err(ProgramError::Custom(0x11));
                }

                if stake_data != *stake_data_info.key {
                    //msg!("invalid stake_data account!");
                    return Err(ProgramError::Custom(0x10));
                }

                let size: u64 = 8 + 32 + 32 + 8 + 1 + 8;
                if stake_data_info.owner != program_id {
                    let required_lamports = rent
                        .minimum_balance(size as usize)
                        .max(1)
                        .saturating_sub(stake_data_info.lamports());

                    invoke(
                        &system_instruction::transfer(payer.key, &stake_data, required_lamports),
                        &[payer.clone(), stake_data_info.clone(), sys_info.clone()],
                    )?;

                    invoke_signed(
                        &system_instruction::allocate(&stake_data, size),
                        &[stake_data_info.clone(), sys_info.clone()],
                        &[&[&mint.key.to_bytes(), &[stake_data_bump]]],
                    )?;

                    invoke_signed(
                        &system_instruction::assign(&stake_data, program_id),
                        &[stake_data_info.clone(), sys_info.clone()],
                        &[&[&mint.key.to_bytes(), &[stake_data_bump]]],
                    )?;
                }

                let harvested =
                    if let Ok(data) = StakeData::try_from_slice(&stake_data_info.data.borrow()) {
                        data.harvested
                    } else {
                        0
                    };

                let stake_struct = StakeData {
                    timestamp: clock.unix_timestamp as u64,
                    staker: *payer.key,
                    harvested: harvested,
                    active: true,
                    withdrawn: 0,
                    mint: *mint.key,
                };
                stake_struct.serialize(&mut &mut stake_data_info.data.borrow_mut()[..])?;

                if &Pubkey::find_program_address(
                    &[
                        "metadata".as_bytes(),
                        &spl_token_metadata::ID.to_bytes(),
                        &mint.key.to_bytes(),
                    ],
                    &spl_token_metadata::ID,
                )
                .0 != metadata_account_info.key
                {
                    //msg!("invalid metadata account!");
                    return Err(ProgramError::Custom(0x03));
                }

                let metadata =
                    spl_token_metadata::state::Metadata::from_account_info(metadata_account_info)?;
                let creators = metadata.data.creators.unwrap();
                let creator = creators.first().unwrap();
                let creator_address = creator.address;

                let (wl_data_address, _wl_data_address_bump) = Pubkey::find_program_address(
                    &[WHITELIST, &creator_address.to_bytes()],
                    &program_id,
                );

                if *whitelist_info.key != wl_data_address {
                    // wrong whitelist_info
                    return Err(ProgramError::Custom(0x900));
                }

                if whitelist_info.owner != program_id {
                    // nft is not whitelisted
                    return Err(ProgramError::Custom(0x902));
                }

                let _wl_rate_data =
                    if let Ok(data) = RateData::try_from_slice(&whitelist_info.data.borrow()) {
                        data.price
                    } else {
                        // can't deserialize rate data
                        return Err(ProgramError::Custom(0x901));
                    };

                if !creator.verified {
                    //msg!("address is not verified");
                    return Err(ProgramError::Custom(0x06));
                }

                let (vault, _vault_bump) = Pubkey::find_program_address(&[&VAULT], &program_id);
                if vault != *vault_info.key {
                    //msg!("Wrong vault");
                    return Err(ProgramError::Custom(0x07));
                }

                if &spl_associated_token_account::get_associated_token_address(payer.key, mint.key)
                    != source.key
                {
                    // msg!("Wrong source");
                    return Err(ProgramError::Custom(0x08));
                }

                if &spl_associated_token_account::get_associated_token_address(&vault, mint.key)
                    != destination.key
                {
                    //msg!("Wrong destination");
                    return Err(ProgramError::Custom(0x09));
                }

                if destination.owner != token_program.key {
                    invoke(
                        &spl_associated_token_account::create_associated_token_account(
                            payer.key,
                            vault_info.key,
                            mint.key,
                        ),
                        &[
                            payer.clone(),
                            destination.clone(),
                            vault_info.clone(),
                            mint.clone(),
                            sys_info.clone(),
                            token_program.clone(),
                            rent_info.clone(),
                            token_assoc.clone(),
                        ],
                    )?;
                }

                invoke(
                    &spl_token::instruction::transfer(
                        token_program.key,
                        source.key,
                        destination.key,
                        payer.key,
                        &[],
                        1,
                    )?,
                    &[
                        source.clone(),
                        destination.clone(),
                        payer.clone(),
                        token_program.clone(),
                    ],
                )?;
            }

            PlatformInstruction::Stake5 => {
                let payer = next_account_info(accounts_iter)?;
                let mint1 = next_account_info(accounts_iter)?;
                let metadata_account_info1 = next_account_info(accounts_iter)?;
                let mint2 = next_account_info(accounts_iter)?;
                let metadata_account_info2 = next_account_info(accounts_iter)?;
                let mint3 = next_account_info(accounts_iter)?;
                let metadata_account_info3 = next_account_info(accounts_iter)?;
                let mint4 = next_account_info(accounts_iter)?;
                let metadata_account_info4 = next_account_info(accounts_iter)?;
                let mint5 = next_account_info(accounts_iter)?;
                let metadata_account_info5 = next_account_info(accounts_iter)?;

                let vault_info = next_account_info(accounts_iter)?;
                let source1 = next_account_info(accounts_iter)?;
                let destination1 = next_account_info(accounts_iter)?;
                let source2 = next_account_info(accounts_iter)?;
                let destination2 = next_account_info(accounts_iter)?;
                let source3 = next_account_info(accounts_iter)?;
                let destination3 = next_account_info(accounts_iter)?;
                let source4 = next_account_info(accounts_iter)?;
                let destination4 = next_account_info(accounts_iter)?;
                let source5 = next_account_info(accounts_iter)?;
                let destination5 = next_account_info(accounts_iter)?;

                let token_program = next_account_info(accounts_iter)?;
                let sys_info = next_account_info(accounts_iter)?;
                let rent_info = next_account_info(accounts_iter)?;
                let token_assoc1 = next_account_info(accounts_iter)?;
                let token_assoc2 = next_account_info(accounts_iter)?;
                let token_assoc3 = next_account_info(accounts_iter)?;
                let token_assoc4 = next_account_info(accounts_iter)?;
                let token_assoc5 = next_account_info(accounts_iter)?;

                let stake_data_info1 = next_account_info(accounts_iter)?;
                let stake_data_info2 = next_account_info(accounts_iter)?;
                let stake_data_info3 = next_account_info(accounts_iter)?;
                let stake_data_info4 = next_account_info(accounts_iter)?;
                let stake_data_info5 = next_account_info(accounts_iter)?;

                let whitelist_info = next_account_info(accounts_iter)?;

                let clock = Clock::get()?;

                if *token_program.key != spl_token::id() {
                    //wrong token_info
                    return Err(ProgramError::Custom(0x345));
                }

                let rent = &Rent::from_account_info(rent_info)?;
                let (stake_data1, stake_data_bump1) =
                    Pubkey::find_program_address(&[&mint1.key.to_bytes()], &program_id);
                let (stake_data2, stake_data_bump2) =
                    Pubkey::find_program_address(&[&mint2.key.to_bytes()], &program_id);
                let (stake_data3, stake_data_bump3) =
                    Pubkey::find_program_address(&[&mint3.key.to_bytes()], &program_id);
                let (stake_data4, stake_data_bump4) =
                    Pubkey::find_program_address(&[&mint4.key.to_bytes()], &program_id);
                let (stake_data5, stake_data_bump5) =
                    Pubkey::find_program_address(&[&mint5.key.to_bytes()], &program_id);

                if !payer.is_signer {
                    //unauthorized access
                    return Err(ProgramError::Custom(0x11));
                }

                if stake_data1 != *stake_data_info1.key
                    || stake_data2 != *stake_data_info2.key
                    || stake_data3 != *stake_data_info3.key
                    || stake_data4 != *stake_data_info4.key
                    || stake_data5 != *stake_data_info5.key
                {
                    //msg!("invalid stake_data account!");
                    return Err(ProgramError::Custom(0x10));
                }

                for i in 1..6 {
                    let (
                        stake_data,
                        stake_data_info,
                        mint,
                        stake_data_bump,
                        token_assoc,
                        metadata_account_info,
                        source,
                        destination,
                    ) = match i {
                        1 => (
                            stake_data1,
                            stake_data_info1,
                            mint1,
                            stake_data_bump1,
                            token_assoc1,
                            metadata_account_info1,
                            source1,
                            destination1,
                        ),
                        2 => (
                            stake_data2,
                            stake_data_info2,
                            mint2,
                            stake_data_bump2,
                            token_assoc2,
                            metadata_account_info2,
                            source2,
                            destination2,
                        ),
                        3 => (
                            stake_data3,
                            stake_data_info3,
                            mint3,
                            stake_data_bump3,
                            token_assoc3,
                            metadata_account_info3,
                            source3,
                            destination3,
                        ),
                        4 => (
                            stake_data4,
                            stake_data_info4,
                            mint4,
                            stake_data_bump4,
                            token_assoc4,
                            metadata_account_info4,
                            source4,
                            destination4,
                        ),
                        5 => (
                            stake_data5,
                            stake_data_info5,
                            mint5,
                            stake_data_bump5,
                            token_assoc5,
                            metadata_account_info5,
                            source5,
                            destination5,
                        ),
                        _ => {
                            return Err(ProgramError::Custom(101));
                        }
                    };

                    let size: u64 = 8 + 32 + 32 + 8 + 1 + 8;
                    if stake_data_info.owner != program_id {
                        let required_lamports = rent
                            .minimum_balance(size as usize)
                            .max(1)
                            .saturating_sub(stake_data_info.lamports());

                        invoke(
                            &system_instruction::transfer(
                                payer.key,
                                &stake_data,
                                required_lamports,
                            ),
                            &[payer.clone(), stake_data_info.clone(), sys_info.clone()],
                        )?;

                        invoke_signed(
                            &system_instruction::allocate(&stake_data, size),
                            &[stake_data_info.clone(), sys_info.clone()],
                            &[&[&mint.key.to_bytes(), &[stake_data_bump]]],
                        )?;

                        invoke_signed(
                            &system_instruction::assign(&stake_data, program_id),
                            &[stake_data_info.clone(), sys_info.clone()],
                            &[&[&mint.key.to_bytes(), &[stake_data_bump]]],
                        )?;
                    }

                    let harvested = if let Ok(data) =
                        StakeData::try_from_slice(&stake_data_info.data.borrow())
                    {
                        data.harvested
                    } else {
                        0
                    };

                    let stake_struct = StakeData {
                        timestamp: clock.unix_timestamp as u64,
                        staker: *payer.key,
                        harvested: harvested,
                        active: true,
                        withdrawn: 0,
                        mint: *mint.key,
                    };
                    stake_struct.serialize(&mut &mut stake_data_info.data.borrow_mut()[..])?;

                    if &Pubkey::find_program_address(
                        &[
                            "metadata".as_bytes(),
                            &spl_token_metadata::ID.to_bytes(),
                            &mint.key.to_bytes(),
                        ],
                        &spl_token_metadata::ID,
                    )
                    .0 != metadata_account_info.key
                    {
                        //msg!("invalid metadata account!");
                        return Err(ProgramError::Custom(0x03));
                    }

                    let metadata = spl_token_metadata::state::Metadata::from_account_info(
                        metadata_account_info,
                    )?;
                    let creators = metadata.data.creators.unwrap();
                    let creator = creators.first().unwrap();
                    let creator_address = creator.address;

                    let (wl_data_address, _wl_data_address_bump) = Pubkey::find_program_address(
                        &[WHITELIST, &creator_address.to_bytes()],
                        &program_id,
                    );

                    if *whitelist_info.key != wl_data_address {
                        // wrong whitelist_info
                        return Err(ProgramError::Custom(0x900));
                    }

                    if whitelist_info.owner != program_id {
                        // nft is not whitelisted
                        return Err(ProgramError::Custom(0x902));
                    }

                    let _wl_rate_data =
                        if let Ok(data) = RateData::try_from_slice(&whitelist_info.data.borrow()) {
                            data.price
                        } else {
                            // can't deserialize rate data
                            return Err(ProgramError::Custom(0x901));
                        };

                    if !creator.verified {
                        //msg!("address is not verified");
                        return Err(ProgramError::Custom(0x06));
                    }

                    let (vault, _vault_bump) = Pubkey::find_program_address(&[&VAULT], &program_id);
                    if vault != *vault_info.key {
                        //msg!("Wrong vault");
                        return Err(ProgramError::Custom(0x07));
                    }

                    if &spl_associated_token_account::get_associated_token_address(
                        payer.key, mint.key,
                    ) != source.key
                    {
                        // msg!("Wrong source");
                        return Err(ProgramError::Custom(0x08));
                    }

                    if &spl_associated_token_account::get_associated_token_address(&vault, mint.key)
                        != destination.key
                    {
                        //msg!("Wrong destination");
                        return Err(ProgramError::Custom(0x09));
                    }

                    if destination.owner != token_program.key {
                        invoke(
                            &spl_associated_token_account::create_associated_token_account(
                                payer.key,
                                vault_info.key,
                                mint.key,
                            ),
                            &[
                                payer.clone(),
                                destination.clone(),
                                vault_info.clone(),
                                mint.clone(),
                                sys_info.clone(),
                                token_program.clone(),
                                rent_info.clone(),
                                token_assoc.clone(),
                            ],
                        )?;
                    }

                    invoke(
                        &spl_token::instruction::transfer(
                            token_program.key,
                            source.key,
                            destination.key,
                            payer.key,
                            &[],
                            1,
                        )?,
                        &[
                            source.clone(),
                            destination.clone(),
                            payer.clone(),
                            token_program.clone(),
                        ],
                    )?;
                }
            }

            PlatformInstruction::Unstake => {
                let payer = next_account_info(accounts_iter)?;
                let system_program = next_account_info(accounts_iter)?;
                let nft_info = next_account_info(accounts_iter)?;
                let token_info = next_account_info(accounts_iter)?;
                let rent_info = next_account_info(accounts_iter)?;
                let assoc_acccount_info = next_account_info(accounts_iter)?;
                let stake_info = next_account_info(accounts_iter)?;
                let vault_info = next_account_info(accounts_iter)?;
                let payer_reward_holder_info = next_account_info(accounts_iter)?;
                let vault_reward_holder_info = next_account_info(accounts_iter)?;
                let payer_nft_holder_info = next_account_info(accounts_iter)?;
                let vault_nft_holder_info = next_account_info(accounts_iter)?;
                let metadata_info = next_account_info(accounts_iter)?;

                let whitelist_info = next_account_info(accounts_iter)?;
                let reward_mint_info = next_account_info(accounts_iter)?;

                let clock = Clock::get()?;

                let (stake_address, _stake_bump) =
                    Pubkey::find_program_address(&[&nft_info.key.to_bytes()], &program_id);
                let (vault_address, vault_bump) =
                    Pubkey::find_program_address(&[&VAULT], &program_id);
                let payer_reward_holder =
                    spl_associated_token_account::get_associated_token_address(
                        payer.key,
                        &reward_mint,
                    );
                let vault_reward_holder =
                    spl_associated_token_account::get_associated_token_address(
                        vault_info.key,
                        &reward_mint,
                    );
                let payer_nft_holder = spl_associated_token_account::get_associated_token_address(
                    payer.key,
                    nft_info.key,
                );
                let vault_nft_holder = spl_associated_token_account::get_associated_token_address(
                    vault_info.key,
                    nft_info.key,
                );
                let (metadata_address, _) = Pubkey::find_program_address(
                    &[
                        "metadata".as_bytes(),
                        &spl_token_metadata::ID.to_bytes(),
                        &nft_info.key.to_bytes(),
                    ],
                    &spl_token_metadata::ID,
                );

                if !payer.is_signer {
                    //unauthorized access
                    return Err(ProgramError::Custom(0x11));
                }

                if *token_info.key != spl_token::id() {
                    //wrong token_info
                    return Err(ProgramError::Custom(0x345));
                }

                if stake_address != *stake_info.key {
                    //wrong stake_info
                    return Err(ProgramError::Custom(0x60));
                }

                if vault_address != *vault_info.key {
                    //wrong stake_info
                    return Err(ProgramError::Custom(0x61));
                }

                if payer_reward_holder != *payer_reward_holder_info.key {
                    //wrong payer_reward_holder_info
                    return Err(ProgramError::Custom(0x62));
                }

                if vault_reward_holder != *vault_reward_holder_info.key {
                    //wrong vault_reward_holder_info
                    return Err(ProgramError::Custom(0x63));
                }

                if payer_nft_holder != *payer_nft_holder_info.key {
                    //wrong payer_nft_holder_info
                    return Err(ProgramError::Custom(0x64));
                }

                if vault_nft_holder != *vault_nft_holder_info.key {
                    //wrong vault_nft_holder_info
                    return Err(ProgramError::Custom(0x65));
                }

                if metadata_address != *metadata_info.key {
                    //wrong metadata_info
                    return Err(ProgramError::Custom(0x66));
                }

                if reward_mint != *reward_mint_info.key {
                    //wrong reward_mint_info
                    return Err(ProgramError::Custom(0x67));
                }

                let metadata =
                    spl_token_metadata::state::Metadata::from_account_info(metadata_info)?;
                let creators = metadata.data.creators.unwrap();
                let creator = creators.first().unwrap();
                let creator_address = creator.address;

                let (wl_data_address, _wl_data_address_bump) = Pubkey::find_program_address(
                    &[WHITELIST, &creator_address.to_bytes()],
                    &program_id,
                );

                if *whitelist_info.key != wl_data_address {
                    // wrong whitelist_info
                    return Err(ProgramError::Custom(0x910));
                }

                let wl_rate_data =
                    if let Ok(data) = RateData::try_from_slice(&whitelist_info.data.borrow()) {
                        data
                    } else {
                        // can't deserialize rate data
                        return Err(ProgramError::Custom(0x911));
                    };

                let vault_data =
                    if let Ok(data) = ContractData::try_from_slice(&vault_info.data.borrow()) {
                        data
                    } else {
                        // can't deserialize vault data
                        return Err(ProgramError::Custom(0x912));
                    };

                let mut stake_data =
                    if let Ok(data) = StakeData::try_from_slice(&stake_info.data.borrow()) {
                        data
                    } else {
                        // can't deserialize stake data
                        return Err(ProgramError::Custom(0x913));
                    };

                if !creator.verified {
                    //msg!("address is not verified");
                    return Err(ProgramError::Custom(0x106));
                }

                if !stake_data.active {
                    //staking is inactive
                    return Err(ProgramError::Custom(0x107));
                }

                if stake_data.staker != *payer.key {
                    //unauthorized access
                    return Err(ProgramError::Custom(0x108));
                }

                let periods =
                    (clock.unix_timestamp as u64 - stake_data.timestamp) / vault_data.reward_period;
                msg!("reward periods passed {:?}", periods);

                let mut reward = 0;
                let mut prev_daily_emission: f64 = 0.0;
                for day in 0..periods {
                    if day >= REWARD_PERIOD - 1 {
                        break;
                    }
                    prev_daily_emission += MX;
                    reward += (prev_daily_emission / NFT_AMOUNT as f64) as u64;
                }

                msg!("reward {:?}", reward);
                msg!("Already harvested {:?}", stake_data.harvested);
                msg!("Max harvested {:?}", wl_rate_data.maxreward);
                reward -= stake_data.withdrawn;
                msg!("Already withdrawn {:?}", stake_data.withdrawn);

                if reward > wl_rate_data.maxreward - stake_data.harvested {
                    reward = wl_rate_data.maxreward - stake_data.harvested;
                }
                msg!("final reward {:?}", reward);

                if payer_reward_holder_info.owner != token_info.key {
                    invoke(
                        &spl_associated_token_account::create_associated_token_account(
                            payer.key,
                            payer.key,
                            reward_mint_info.key,
                        ),
                        &[
                            payer.clone(),
                            payer_reward_holder_info.clone(),
                            payer.clone(),
                            reward_mint_info.clone(),
                            system_program.clone(),
                            token_info.clone(),
                            rent_info.clone(),
                            assoc_acccount_info.clone(),
                        ],
                    )?;
                }

                invoke_signed(
                    &spl_token::instruction::transfer(
                        token_info.key,
                        vault_reward_holder_info.key,
                        payer_reward_holder_info.key,
                        vault_info.key,
                        &[],
                        reward,
                    )?,
                    &[
                        vault_reward_holder_info.clone(),
                        payer_reward_holder_info.clone(),
                        vault_info.clone(),
                        token_info.clone(),
                    ],
                    &[&[&VAULT, &[vault_bump]]],
                )?;

                if payer_nft_holder_info.owner != token_info.key {
                    invoke(
                        &spl_associated_token_account::create_associated_token_account(
                            payer.key,
                            payer.key,
                            nft_info.key,
                        ),
                        &[
                            payer.clone(),
                            payer_nft_holder_info.clone(),
                            payer.clone(),
                            nft_info.clone(),
                            system_program.clone(),
                            token_info.clone(),
                            rent_info.clone(),
                            assoc_acccount_info.clone(),
                        ],
                    )?;
                }

                invoke_signed(
                    &spl_token::instruction::transfer(
                        token_info.key,
                        vault_nft_holder_info.key,
                        payer_nft_holder_info.key,
                        vault_info.key,
                        &[],
                        1,
                    )?,
                    &[
                        vault_nft_holder_info.clone(),
                        payer_nft_holder_info.clone(),
                        vault_info.clone(),
                        token_info.clone(),
                    ],
                    &[&[&VAULT, &[vault_bump]]],
                )?;

                invoke_signed(
                    &spl_token::instruction::close_account(
                        token_info.key,
                        vault_nft_holder_info.key,
                        payer.key,
                        vault_info.key,
                        &[],
                    )?,
                    &[
                        vault_nft_holder_info.clone(),
                        payer.clone(),
                        vault_info.clone(),
                        token_info.clone(),
                    ],
                    &[&[&VAULT, &[vault_bump]]],
                )?;
                stake_data.active = false;
                stake_data.harvested += reward;
                stake_data.withdrawn += reward;
                stake_data.serialize(&mut &mut stake_info.data.borrow_mut()[..])?;
            }

            PlatformInstruction::Claim => {
                let payer = next_account_info(accounts_iter)?;
                let system_program = next_account_info(accounts_iter)?;
                let nft_info = next_account_info(accounts_iter)?;
                let token_info = next_account_info(accounts_iter)?;
                let rent_info = next_account_info(accounts_iter)?;
                let assoc_acccount_info = next_account_info(accounts_iter)?;
                let stake_info = next_account_info(accounts_iter)?;
                let vault_info = next_account_info(accounts_iter)?;
                let payer_reward_holder_info = next_account_info(accounts_iter)?;
                let vault_reward_holder_info = next_account_info(accounts_iter)?;
                let payer_nft_holder_info = next_account_info(accounts_iter)?;
                let vault_nft_holder_info = next_account_info(accounts_iter)?;
                let metadata_info = next_account_info(accounts_iter)?;

                let whitelist_info = next_account_info(accounts_iter)?;
                let reward_mint_info = next_account_info(accounts_iter)?;

                let clock = Clock::get()?;

                let (stake_address, _stake_bump) =
                    Pubkey::find_program_address(&[&nft_info.key.to_bytes()], &program_id);
                let (vault_address, vault_bump) =
                    Pubkey::find_program_address(&[&VAULT], &program_id);
                let payer_reward_holder =
                    spl_associated_token_account::get_associated_token_address(
                        payer.key,
                        &reward_mint,
                    );
                let vault_reward_holder =
                    spl_associated_token_account::get_associated_token_address(
                        vault_info.key,
                        &reward_mint,
                    );
                let payer_nft_holder = spl_associated_token_account::get_associated_token_address(
                    payer.key,
                    nft_info.key,
                );
                let vault_nft_holder = spl_associated_token_account::get_associated_token_address(
                    vault_info.key,
                    nft_info.key,
                );
                let (metadata_address, _) = Pubkey::find_program_address(
                    &[
                        "metadata".as_bytes(),
                        &spl_token_metadata::ID.to_bytes(),
                        &nft_info.key.to_bytes(),
                    ],
                    &spl_token_metadata::ID,
                );

                if !payer.is_signer {
                    //unauthorized access
                    return Err(ProgramError::Custom(0x11));
                }

                if *token_info.key != spl_token::id() {
                    //wrong token_info
                    return Err(ProgramError::Custom(0x345));
                }

                if stake_address != *stake_info.key {
                    //wrong stake_info
                    return Err(ProgramError::Custom(0x60));
                }

                if vault_address != *vault_info.key {
                    //wrong stake_info
                    return Err(ProgramError::Custom(0x61));
                }

                if payer_reward_holder != *payer_reward_holder_info.key {
                    //wrong payer_reward_holder_info
                    return Err(ProgramError::Custom(0x62));
                }

                if vault_reward_holder != *vault_reward_holder_info.key {
                    //wrong vault_reward_holder_info
                    return Err(ProgramError::Custom(0x63));
                }

                if payer_nft_holder != *payer_nft_holder_info.key {
                    //wrong payer_nft_holder_info
                    return Err(ProgramError::Custom(0x64));
                }

                if vault_nft_holder != *vault_nft_holder_info.key {
                    //wrong vault_nft_holder_info
                    return Err(ProgramError::Custom(0x65));
                }

                if metadata_address != *metadata_info.key {
                    //wrong metadata_info
                    return Err(ProgramError::Custom(0x66));
                }

                if reward_mint != *reward_mint_info.key {
                    //wrong reward_mint_info
                    return Err(ProgramError::Custom(0x67));
                }

                let metadata =
                    spl_token_metadata::state::Metadata::from_account_info(metadata_info)?;
                let creators = metadata.data.creators.unwrap();
                let creator = creators.first().unwrap();
                let creator_address = creator.address;

                let (wl_data_address, _wl_data_address_bump) = Pubkey::find_program_address(
                    &[WHITELIST, &creator_address.to_bytes()],
                    &program_id,
                );

                if *whitelist_info.key != wl_data_address {
                    // wrong whitelist_info
                    return Err(ProgramError::Custom(0x910));
                }

                let wl_rate_data =
                    if let Ok(data) = RateData::try_from_slice(&whitelist_info.data.borrow()) {
                        data
                    } else {
                        // can't deserialize rate data
                        return Err(ProgramError::Custom(0x911));
                    };

                let vault_data =
                    if let Ok(data) = ContractData::try_from_slice(&vault_info.data.borrow()) {
                        data
                    } else {
                        // can't deserialize vault data
                        return Err(ProgramError::Custom(0x912));
                    };

                let mut stake_data =
                    if let Ok(data) = StakeData::try_from_slice(&stake_info.data.borrow()) {
                        data
                    } else {
                        // can't deserialize stake data
                        return Err(ProgramError::Custom(0x913));
                    };

                if !creator.verified {
                    //msg!("address is not verified");
                    return Err(ProgramError::Custom(0x106));
                }

                if !stake_data.active {
                    //staking is inactive
                    return Err(ProgramError::Custom(0x107));
                }

                if stake_data.staker != *payer.key {
                    //unauthorized access
                    return Err(ProgramError::Custom(0x108));
                }

                let periods =
                    (clock.unix_timestamp as u64 - stake_data.timestamp) / vault_data.reward_period;
                msg!("reward periods passed {:?}", periods);

                let mut reward = 0;
                let mut prev_daily_emission: f64 = 0.0;
                for day in 0..periods {
                    if day >= REWARD_PERIOD - 1 {
                        break;
                    }
                    prev_daily_emission += MX;
                    reward += (prev_daily_emission / NFT_AMOUNT as f64) as u64;
                }

                msg!("reward {:?}", reward);
                msg!("Already harvested {:?}", stake_data.harvested);
                msg!("Max harvested {:?}", wl_rate_data.maxreward);
                reward -= stake_data.withdrawn;
                msg!("Already withdrawn {:?}", stake_data.withdrawn);

                if reward > wl_rate_data.maxreward - stake_data.harvested {
                    reward = wl_rate_data.maxreward - stake_data.harvested;
                }
                msg!("final reward {:?}", reward);

                if payer_reward_holder_info.owner != token_info.key {
                    invoke(
                        &spl_associated_token_account::create_associated_token_account(
                            payer.key,
                            payer.key,
                            reward_mint_info.key,
                        ),
                        &[
                            payer.clone(),
                            payer_reward_holder_info.clone(),
                            payer.clone(),
                            reward_mint_info.clone(),
                            system_program.clone(),
                            token_info.clone(),
                            rent_info.clone(),
                            assoc_acccount_info.clone(),
                        ],
                    )?;
                }

                invoke_signed(
                    &spl_token::instruction::transfer(
                        token_info.key,
                        vault_reward_holder_info.key,
                        payer_reward_holder_info.key,
                        vault_info.key,
                        &[],
                        reward,
                    )?,
                    &[
                        vault_reward_holder_info.clone(),
                        payer_reward_holder_info.clone(),
                        vault_info.clone(),
                        token_info.clone(),
                    ],
                    &[&[&VAULT, &[vault_bump]]],
                )?;

                stake_data.harvested += reward;
                stake_data.withdrawn += reward;
                stake_data.serialize(&mut &mut stake_info.data.borrow_mut()[..])?;
            }
        };

        Ok(())
    }
}
