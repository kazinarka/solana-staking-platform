use std::slice::Iter;
use solana_program::account_info::{AccountInfo, next_account_info};
use solana_program::entrypoint::ProgramResult;
use solana_program::program::{invoke, invoke_signed};
use solana_program::program_error::ProgramError;
use solana_program::pubkey::Pubkey;
use solana_program::rent::Rent;
use solana_program::system_instruction;
use solana_program::sysvar::Sysvar;
use crate::consts::{ADMIN, VAULT, WHITELIST};

pub fn generate_vault(accounts_iter:&mut Iter<AccountInfo>, program_id: &Pubkey) -> ProgramResult {
    let payer = next_account_info(accounts_iter)?;
    let system_program = next_account_info(accounts_iter)?;
    let pda = next_account_info(accounts_iter)?;
    let rent_info = next_account_info(accounts_iter)?;

    let rent = &Rent::from_account_info(rent_info)?;

    let (vault_pda, vault_bump_seed) =
        Pubkey::find_program_address(&[VAULT], &program_id);

    if pda.key != &vault_pda {
        //msg!("Wrong account generated by client");
        return Err(ProgramError::Custom(0x00));
    }

    let admin = ADMIN.parse::<Pubkey>().unwrap();

    if *payer.key != admin || !payer.is_signer {
        //unauthorized access
        return Err(ProgramError::Custom(0x02));
    }

    if pda.owner != program_id {
        let required_lamports = rent
            .minimum_balance(0)
            .max(1)
            .saturating_sub(pda.lamports());

        invoke(
            &system_instruction::transfer(payer.key, &vault_pda, required_lamports),
            &[payer.clone(), pda.clone(), system_program.clone()],
        )?;

        invoke_signed(
            &system_instruction::assign(&vault_pda, program_id),
            &[pda.clone(), system_program.clone()],
            &[&[VAULT, &[vault_bump_seed]]],
        )?;
    }

    Ok(())
}

pub fn add_to_whitelist(accounts_iter:&mut Iter<AccountInfo>, program_id: &Pubkey) -> ProgramResult {
    let payer = next_account_info(accounts_iter)?;
    let creator_info = next_account_info(accounts_iter)?;
    let whitelist_info = next_account_info(accounts_iter)?;
    let sys_info = next_account_info(accounts_iter)?;
    let rent_info = next_account_info(accounts_iter)?;

    let rent = &Rent::from_account_info(rent_info)?;

    let admin = ADMIN.parse::<Pubkey>().unwrap();

    if *payer.key != admin || !payer.is_signer {
        //unauthorized access
        return Err(ProgramError::Custom(0x31));
    }

    let (data_address, data_address_bump) = Pubkey::find_program_address(
        &[WHITELIST, &creator_info.key.to_bytes()],
        &program_id,
    );

    if *whitelist_info.key != data_address {
        //wrong whitelist_info
        return Err(ProgramError::Custom(0x32));
    }

    if whitelist_info.owner != program_id {
        let required_lamports = rent
            .minimum_balance(0)
            .max(1)
            .saturating_sub(whitelist_info.lamports());

        invoke(
            &system_instruction::transfer(payer.key, &data_address, required_lamports),
            &[payer.clone(), whitelist_info.clone(), sys_info.clone()],
        )?;

        invoke_signed(
            &system_instruction::assign(&data_address, program_id),
            &[whitelist_info.clone(), sys_info.clone()],
            &[&[
                WHITELIST,
                &creator_info.key.to_bytes(),
                &[data_address_bump],
            ]],
        )?;
    }

    Ok(())
}